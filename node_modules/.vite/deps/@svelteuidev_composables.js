import "./chunk-3BQGYF6B.js";
import {
  writable
} from "./chunk-Y5HQ3MVM.js";
import {
  onMount,
  tick
} from "./chunk-ZQ7TCJTX.js";
import "./chunk-OROXOI2D.js";

// node_modules/@svelteuidev/composables/actions/use-click-outside/use-click-outside.js
function clickoutside(node, params) {
  const { enabled: initialEnabled, callback } = params;
  const handleOutsideClick = ({ target }) => {
    if (!node.contains(target))
      callback(node);
  };
  function update({ enabled }) {
    if (enabled) {
      window.addEventListener("click", handleOutsideClick);
    } else {
      window.removeEventListener("click", handleOutsideClick);
    }
  }
  update({ enabled: initialEnabled });
  return {
    update,
    destroy() {
      window.removeEventListener("click", handleOutsideClick);
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-clipboard/use-clipboard.js
function clipboard(node, text) {
  const click = async () => {
    if (text)
      try {
        await navigator.clipboard.writeText(text);
        node.dispatchEvent(new CustomEvent("useclipboard", { detail: text }));
      } catch (e) {
        node.dispatchEvent(new CustomEvent("useclipboard-error", { detail: e }));
      }
  };
  node.addEventListener("click", click, true);
  return {
    update: (t) => text = t,
    destroy: () => node.removeEventListener("click", click, true)
  };
}

// node_modules/@svelteuidev/composables/actions/use-css-variable/use-css-variable.js
function cssvariable(node, props) {
  Object.entries(props).forEach(([key, value]) => {
    node.style.setProperty(`--${key}`, `${value}`);
  });
  return {
    update(_props) {
      Object.entries(_props).forEach(([key, value]) => {
        node.style.setProperty(`--${key}`, `${value}`);
        delete props[key];
      });
      Object.keys(props).forEach((name) => node.style.removeProperty(`--${name}`));
      props = _props;
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-download/use-download.js
function download(node, params) {
  const click = async () => {
    const { blob, filename } = params;
    try {
      const anchor = document.createElement("a");
      const url = URL.createObjectURL(blob);
      anchor.href = url;
      anchor.download = filename || "";
      document.body.appendChild(anchor);
      anchor.click();
      await tick();
      document.body.removeChild(anchor);
      URL.revokeObjectURL(url);
      node.dispatchEvent(new CustomEvent("usedownload", { detail: { blob, filename } }));
    } catch (e) {
      node.dispatchEvent(new CustomEvent("usedownload-error", { detail: { blob, filename } }));
    }
  };
  node.addEventListener("click", click, true);
  return {
    update: (_params) => params = _params,
    destroy: () => node.removeEventListener("click", click, true)
  };
}

// node_modules/@svelteuidev/composables/actions/use-focus/use-focus.js
function focus(node) {
  node.focus();
  return;
}

// node_modules/@svelteuidev/composables/actions/use-hot-key/parse-hotkey.js
function parseHotkey(hotkey2) {
  const keys = hotkey2.toLowerCase().split("+").map((part) => part.trim());
  const modifiers = {
    alt: keys.includes("alt"),
    ctrl: keys.includes("ctrl"),
    meta: keys.includes("meta"),
    mod: keys.includes("mod"),
    shift: keys.includes("shift")
  };
  const reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"];
  const freeKey = keys.find((key) => !reservedKeys.includes(key));
  return {
    ...modifiers,
    key: freeKey
  };
}
function isExactHotkey(hotkey2, event) {
  const { alt, ctrl, meta, mod, shift, key } = hotkey2;
  const { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey } = event;
  if (alt !== altKey) {
    return false;
  }
  if (mod) {
    if (!ctrlKey && !metaKey) {
      return false;
    }
  } else {
    if (ctrl !== ctrlKey) {
      return false;
    }
    if (meta !== metaKey) {
      return false;
    }
  }
  if (shift !== shiftKey) {
    return false;
  }
  if (key && (pressedKey.toLowerCase() === key.toLowerCase() || event.code.replace("Key", "").toLowerCase() === key.toLowerCase())) {
    return true;
  }
  return false;
}
function getHotkeyMatcher(hotkey2) {
  return (event) => isExactHotkey(parseHotkey(hotkey2), event);
}
function getHotkeyHandler(hotkeys) {
  return (event) => {
    hotkeys.forEach(([hotkey2, handler]) => {
      if (getHotkeyMatcher(hotkey2)(event)) {
        event.preventDefault();
        handler(event);
      }
    });
  };
}

// node_modules/@svelteuidev/composables/actions/use-hot-key/use-hot-key.js
function shouldFireEvent(event) {
  if (event.target instanceof HTMLElement) {
    return !["INPUT", "TEXTAREA", "SELECT"].includes(event.target.tagName);
  }
}
function hotkey(node, hotkeys) {
  const keyDownListener = (event) => {
    hotkeys.forEach(([hotkey2, handler]) => {
      if (getHotkeyMatcher(hotkey2)(event) && shouldFireEvent(event)) {
        event.preventDefault();
        handler(event);
      }
    });
  };
  document.documentElement.addEventListener("keydown", keyDownListener);
  return {
    update: (updatedHotKeys) => {
      hotkeys = updatedHotKeys;
    },
    destroy: () => {
      document.documentElement.addEventListener("keydown", keyDownListener);
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-io/use-io.js
var createEvent = (name, detail) => new CustomEvent(name, { detail });
var defaultOptions = {
  root: null,
  rootMargin: "0px",
  threshold: 0,
  unobserveOnEnter: false
};
function io(node, options = {}) {
  const { root, rootMargin, threshold, unobserveOnEnter } = { ...defaultOptions, ...options };
  let prevPosition = {
    x: void 0,
    y: void 0
  };
  const scrollDirection = {
    vertical: void 0,
    horizontal: void 0
  };
  if (typeof IntersectionObserver !== "undefined" && node) {
    const observer2 = new IntersectionObserver((entries, _observer) => {
      entries.forEach((singleEntry) => {
        if (prevPosition.y > singleEntry.boundingClientRect.y) {
          scrollDirection.vertical = "up";
        } else {
          scrollDirection.vertical = "down";
        }
        if (prevPosition.x > singleEntry.boundingClientRect.x) {
          scrollDirection.horizontal = "left";
        } else {
          scrollDirection.horizontal = "right";
        }
        prevPosition = {
          y: singleEntry.boundingClientRect.y,
          x: singleEntry.boundingClientRect.x
        };
        const detail = {
          inView: singleEntry.isIntersecting,
          entry: singleEntry,
          scrollDirection,
          node,
          observer: _observer
        };
        node.dispatchEvent(createEvent("change", detail));
        if (singleEntry.isIntersecting) {
          node.dispatchEvent(createEvent("enter", detail));
          unobserveOnEnter && _observer.unobserve(node);
        } else {
          node.dispatchEvent(createEvent("leave", detail));
        }
      });
    }, {
      root,
      rootMargin,
      threshold
    });
    setTimeout(() => {
      node.dispatchEvent(createEvent("init", { observer: observer2, node }));
    }, 0);
    observer2.observe(node);
    return {
      destroy: () => {
        observer2.unobserve(node);
      }
    };
  }
}

// node_modules/@svelteuidev/composables/actions/use-io/use-io.config.js
var use_io_config_exports = {};

// node_modules/@svelteuidev/composables/actions/use-lazy/use-lazy.js
var nodeAttributesMap = /* @__PURE__ */ new WeakMap();
var intersection_handler = (entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting && entry.target instanceof HTMLElement) {
      const node = entry.target;
      Object.assign(node, nodeAttributesMap.get(node));
      lazyLoadObserver.unobserve(node);
    }
  });
};
var lazyLoadObserver;
function observer() {
  return lazyLoadObserver != null ? lazyLoadObserver : lazyLoadObserver = new IntersectionObserver(intersection_handler);
}
function lazy(node, attributes) {
  nodeAttributesMap.set(node, attributes);
  observer().observe(node);
  return {
    destroy() {
      observer().unobserve(node);
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-lock-scroll/utils/create-style-tag.js
function createStyleTag() {
  const tag = document.createElement("style");
  tag.type = "text/css";
  tag.setAttribute("svelteui-scroll-lock", "");
  return tag;
}

// node_modules/@svelteuidev/composables/actions/use-lock-scroll/utils/get-scroll-width.js
function getScrollWidth() {
  if (typeof window === "undefined" || typeof document === "undefined")
    return 0;
  const paddingRight = parseInt(window.getComputedStyle(document.body).paddingRight, 10);
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  return paddingRight + scrollbarWidth;
}

// node_modules/@svelteuidev/composables/actions/use-lock-scroll/utils/get-lock-styles.js
var getLockStyles = ({ disableBodyPadding }) => {
  const scrollWidth = disableBodyPadding ? null : getScrollWidth();
  const styles = `body {
        --removed-scroll-width: ${scrollWidth}px;
        touch-action: none;
        overflow: hidden !important;
        position: relative !important;
        ${scrollWidth ? "padding-right: var(--removed-scroll-width) !important;" : ""}
        `;
  return styles;
};

// node_modules/@svelteuidev/composables/actions/use-lock-scroll/utils/inject-style-tag.js
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}

// node_modules/@svelteuidev/composables/actions/use-lock-scroll/utils/insert-style-tag.js
function insertStyleTag(tag) {
  const head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}

// node_modules/@svelteuidev/composables/shared/actions/utils/environment.js
var isBrowser = () => typeof window !== "undefined";
var ENVIRONMENT = {
  browser: isBrowser(),
  server: !isBrowser()
};
var defaultWindow = ENVIRONMENT.browser ? window : void 0;

// node_modules/@svelteuidev/composables/actions/use-lock-scroll/use-lock-scroll.js
function lockscroll(node, lock, options = { disableBodyPadding: false }) {
  const { browser: browser3 } = ENVIRONMENT;
  let window2;
  if (browser3) {
    window2 = defaultWindow;
  }
  let scrollLocked = lock != null ? lock : false;
  const { disableBodyPadding } = options;
  let stylesheet;
  const lockScroll = () => {
    const styles = getLockStyles({ disableBodyPadding });
    const sheet = createStyleTag();
    injectStyles(sheet, styles);
    insertStyleTag(sheet);
    stylesheet = sheet;
  };
  const unlockScroll = () => {
    var _a;
    if (!stylesheet)
      return;
    (_a = stylesheet == null ? void 0 : stylesheet.parentNode) == null ? void 0 : _a.removeChild(stylesheet);
    stylesheet = null;
  };
  if (scrollLocked) {
    lockScroll();
  } else {
    unlockScroll();
  }
  if (lock !== void 0) {
    scrollLocked = lock;
  }
  if (lock === void 0 && typeof window2 !== "undefined") {
    window2.document.body.style.overflow === "hidden" && (scrollLocked = lock);
  }
  return {
    update: (locked) => {
      if (locked) {
        lockScroll();
      } else {
        window2.document.body.style.overflow === "visible" && (scrollLocked = lock);
        unlockScroll();
      }
    },
    destroy: () => {
      unlockScroll();
      return;
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-long-press/use-long-press.js
function longpress(node, duration) {
  let timer;
  function handlePress() {
    timer = window.setTimeout(() => {
      node.dispatchEvent(new CustomEvent("uselongpress"));
    }, duration);
  }
  function handleRelease() {
    clearTimeout(timer);
  }
  node.addEventListener("mousedown", handlePress);
  node.addEventListener("mouseup", handleRelease);
  node.addEventListener("touchstart", handlePress);
  node.addEventListener("touchend", handleRelease);
  return {
    update(newDuration) {
      handleRelease();
      duration = newDuration;
    },
    destroy() {
      handleRelease();
      node.removeEventListener("mousedown", handlePress);
      node.removeEventListener("mouseup", handleRelease);
      node.removeEventListener("touchstart", handlePress);
      node.removeEventListener("touchstart", handleRelease);
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-page-leave/use-page-leave.js
function pageleave(node, callback) {
  document.documentElement.addEventListener("mouseleave", callback);
  return {
    destroy() {
      document.documentElement.removeEventListener("mouseleave", callback);
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-persistent-tab/use-persistent-tab.js
function persistenttab(node, enabled) {
  function handler(e) {
    e.preventDefault();
    e.returnValue = "";
  }
  function setHandler(prevent) {
    (prevent ? window.addEventListener : window.removeEventListener)("beforeunload", handler);
  }
  setHandler(enabled);
  return {
    update: setHandler,
    destroy() {
      setHandler(false);
    }
  };
}

// node_modules/@svelteuidev/composables/actions/use-portal/use-portal.js
function portal(node, target = "body") {
  let targetNode;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetNode = document.querySelector(target);
      if (targetNode === null) {
        await tick();
        targetNode = document.querySelector(target);
      }
      if (targetNode === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetNode = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetNode.appendChild(node);
    node.hidden = false;
  }
  function destroy() {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  update(target);
  return {
    update,
    destroy
  };
}

// node_modules/@svelteuidev/composables/actions/use-tab-leave/use-tab-leave.js
function tableave(node, callback) {
  document.addEventListener("visibilitychange", callback);
  return {
    destroy() {
      document.removeEventListener("visibilitychange", callback);
    }
  };
}

// node_modules/@svelteuidev/composables/shared/utilities/utils/_configurable.js
var isBrowser2 = () => typeof window !== "undefined";
var browser = isBrowser2();
var defaultWindow2 = browser ? window : void 0;
var defaultDocument = browser ? window.document : void 0;
var defaultNavigator = browser ? window.navigator : void 0;
var defaultLocation = browser ? window.location : void 0;

// node_modules/@svelteuidev/composables/shared/utilities/utils/is/is.js
var toString = Object.prototype.toString;
var isClient = typeof window !== void 0;
var isBoolean = (val) => typeof val === "boolean";
var isFunction = (val) => typeof val === "function";
var isNumber = (val) => typeof val === "number";
var isString = (val) => typeof val === "string";
var isObject = (val) => toString.call(val) === "[object Object]";
var isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
var now = () => Date.now();
var timestamp = () => +Date.now();
var sleep = (ms = 2e3) => new Promise((r) => setTimeout(r, ms));
var rand = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

// node_modules/@svelteuidev/composables/shared/utilities/utils/time/time.js
var dateTimeString = (timestamp2, locale = void 0, options = {
  dateStyle: "short",
  timeStyle: "short"
}) => {
  const date = new Date(timestamp2);
  return new Intl.DateTimeFormat(locale, options).format(date);
};

// node_modules/@svelteuidev/composables/shared/utilities/utils/random-id/random-id.js
function randomID() {
  return `svelteui-${Math.random().toString(36).substring(2, 10)}`;
}

// node_modules/@svelteuidev/composables/utilities/use-browser-context/use-browser-context.js
var listenerOptions = {
  passive: true
};
function useBrowserContext() {
  let window2;
  if (browser)
    window2 = defaultWindow2;
  const setState = (trigger) => {
    var _a, _b;
    const { state: state2, length } = (_a = window2 == null ? void 0 : window2.history) != null ? _a : {};
    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (_b = window2 == null ? void 0 : window2.location) != null ? _b : {};
    return {
      trigger,
      state: state2,
      length,
      hash,
      host,
      hostname,
      href,
      origin,
      pathname,
      port,
      protocol,
      search
    };
  };
  const state = writable(setState("load"));
  onMount(() => {
    window2.addEventListener("popstate", () => state.set(setState("popstate")), listenerOptions);
    window2.addEventListener("hashchange", () => state.set(setState("hashchange")), listenerOptions);
    return () => {
      window2.removeEventListener("popstate", () => state.set(setState("popstate")));
      window2.removeEventListener("hashchange", () => state.set(setState("hashchange")));
    };
  });
  return state;
}

// node_modules/@svelteuidev/composables/shared/utils/upper-first/upper-first.js
function upperFirst(value) {
  return typeof value !== "string" ? "" : value.charAt(0).toUpperCase() + value.slice(1);
}

// node_modules/@svelteuidev/composables/shared/utils/filter/debounce.js
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = ms;
    const maxDuration = options.maxWait;
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}

// node_modules/@svelteuidev/composables/shared/utils/filter/filter.js
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}

// node_modules/@svelteuidev/composables/shared/utils/filter/throttle.js
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };
  const filter = (invoke) => {
    const duration = ms;
    const elapsed = Date.now() - lastExec;
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        isLeading = true;
        clear();
        invoke();
      }, duration);
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
  };
  return filter;
}

// node_modules/@svelteuidev/composables/utilities/use-debounce/use-debounce.js
function useDebounce(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}

// node_modules/@svelteuidev/composables/utilities/use-eye-dropper/use-eye-dropper.js
function useEyeDropper(options = {}) {
  let window2;
  if (browser)
    window2 = defaultWindow2;
  const { initialValue = "" } = options;
  const isSupported = Boolean(typeof window2 !== "undefined" && "EyeDropper" in window2);
  const sRGBHex = writable(initialValue);
  async function open(openOptions) {
    if (!isSupported)
      return;
    const eyeDropper = new window2.EyeDropper();
    const res = await eyeDropper.open(openOptions);
    sRGBHex.set(res.sRGBHex);
    return res;
  }
  return {
    isSupported,
    sRGBHex,
    open
  };
}

// node_modules/@svelteuidev/composables/utilities/use-focus-within/use-focus-within.js
function containsRelatedTarget(event) {
  if (event.currentTarget instanceof HTMLElement && event.relatedTarget instanceof HTMLElement) {
    return event.currentTarget.contains(event.relatedTarget);
  }
  return false;
}
function useFocusWithin({ onBlur, onFocus } = {}) {
  const focused = writable(false);
  let focusedRef = false;
  const setFocused = (value) => {
    focused.set(value);
    focusedRef = value;
  };
  const handleFocusIn = (event) => {
    if (!focusedRef) {
      setFocused(true);
      onFocus == null ? void 0 : onFocus(event);
    }
  };
  const handleFocusOut = (event) => {
    if (focusedRef && !containsRelatedTarget(event)) {
      setFocused(false);
      onBlur == null ? void 0 : onBlur(event);
    }
  };
  const focuswithin = (node) => {
    node == null ? void 0 : node.addEventListener("focusin", handleFocusIn);
    node == null ? void 0 : node.addEventListener("focusout", handleFocusOut);
    return {
      destroy: () => {
        node == null ? void 0 : node.removeEventListener("focusin", handleFocusIn);
        node == null ? void 0 : node.removeEventListener("focusout", handleFocusOut);
      }
    };
  };
  return [focused, focuswithin];
}

// node_modules/@svelteuidev/composables/utilities/use-hash/use-hash.js
function useHash(prefix = "svelteui", persist = false) {
  if (persist && browser) {
    let hash = `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
    if (localStorage[`${prefix}-hash`] !== void 0) {
      hash = localStorage.getItem(`${prefix}-hash`);
    } else {
      localStorage.setItem(`${prefix}-hash`, hash);
    }
    return hash;
  }
  return `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
}

// node_modules/@svelteuidev/composables/utilities/use-mouse-position/use-mouse-position.js
function useMousePosition(append = false) {
  const position = writable({ x: 0, y: 0 });
  const setMousePosition = (event) => {
    if (append === false) {
      const target = event.currentTarget;
      const rect = target.getBoundingClientRect();
      const x = Math.max(0, Math.round(event.pageX - rect.left - (window.pageXOffset || window.scrollX)));
      const y = Math.max(0, Math.round(event.pageY - rect.top - (window.pageYOffset || window.scrollY)));
      position.set({ x, y });
    } else {
      position.set({ x: event.clientX, y: event.clientY });
    }
  };
  const mouseposition = (node) => {
    const element = !append ? node : document;
    element.addEventListener("mousemove", setMousePosition);
    return {
      destroy: () => {
        element.removeEventListener("mousemove", setMousePosition);
      }
    };
  };
  return [position, mouseposition];
}

// node_modules/@svelteuidev/composables/utilities/use-os/use-os.js
function getOS() {
  const { userAgent } = window.navigator;
  const { platform } = window.navigator;
  const macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"];
  const windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"];
  const iosPlatforms = ["iPhone", "iPad", "iPod"];
  let os = "undetermined";
  if (macosPlatforms.indexOf(platform) !== -1) {
    os = "macos";
  } else if (iosPlatforms.indexOf(platform) !== -1) {
    os = "ios";
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    os = "windows";
  } else if (/iPhone|iPad|iPod/i.test(userAgent)) {
    os = "ios";
  } else if (/Win/i.test(userAgent)) {
    os = "windows";
  } else if (/Android/i.test(userAgent)) {
    os = "android";
  } else if (/Mac/i.test(userAgent)) {
    os = "macos";
  } else if (/Linux/i.test(userAgent)) {
    os = "linux";
  }
  return os;
}
function useOs() {
  if (typeof window !== "undefined") {
    return getOS();
  }
  return "undetermined";
}

// node_modules/@svelteuidev/composables/utilities/use-raf-fn/use-raf-fn.js
var isBrowser3 = () => typeof window !== "undefined";
var browser2 = isBrowser3();
function useRafFn(fn, options = {}) {
  const { immediate = true } = options;
  let isActive = false;
  async function loop() {
    if (!isActive)
      return;
    try {
      fn();
      if (browser2)
        await window.requestAnimationFrame(loop);
    } catch (err) {
      console.error(err);
    }
  }
  function resume() {
    if (!isActive) {
      isActive = true;
      loop();
    }
  }
  function pause() {
    isActive = false;
  }
  if (immediate)
    resume();
  return {
    isActive,
    pause,
    resume
  };
}

// node_modules/@svelteuidev/composables/utilities/use-regex/use-regex.js
var PATTERN_BANK = [
  { name: "getAllOf", pattern: "(?:^|W)%svelteui%(?:$|W)" }
];
var useRegexOptions = {
  test: false,
  testType: "test",
  testString: ""
};
function useRegexFactory(extensions = []) {
  const patternBank = [...PATTERN_BANK, ...extensions];
  function useRegex(name, matcher, options = useRegexOptions) {
    let pattern;
    const { test, testType, testString } = { ...useRegexOptions, ...options };
    patternBank.forEach((_pattern) => {
      if (name === _pattern.name)
        pattern = _pattern.pattern;
    });
    pattern = pattern.replace(/%svelteui%/g, matcher);
    const regex = new RegExp(pattern, testType === "match-all" ? "g" : null);
    if (test) {
      let value;
      switch (testType) {
        case "test":
          value = regex.test(testString);
          break;
        case "search":
          value = testString.search(regex);
          break;
        case "match":
          value = testString.match(regex);
          break;
        case "match-all":
          value = testString.matchAll(regex);
          break;
        default:
          break;
      }
      return value;
    }
    return regex;
  }
  return useRegex;
}

// node_modules/@svelteuidev/composables/utilities/use-throttle/use-throttle.js
function useThrottle(fn, ms = 200, trailing = true, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}

// node_modules/@svelteuidev/composables/utilities/use-viewport-size/use-viewport-size.js
var listenerOptions2 = {
  passive: true
};
function useViewportSize() {
  let window2;
  if (browser)
    window2 = defaultWindow2;
  const windowSize = writable({
    width: browser ? window2.innerWidth : 0,
    height: browser ? window2.innerHeight : 0
  });
  const setSize = () => {
    windowSize.set({
      width: window2.innerWidth || 0,
      height: window2.innerHeight || 0
    });
  };
  if (browser) {
    window2.addEventListener("resize", setSize, listenerOptions2);
    window2.addEventListener("orientationchange", setSize, listenerOptions2);
  }
  return windowSize;
}

// node_modules/@svelteuidev/composables/shared/actions/utils/clamp.js
function clamp({ value, min, max }) {
  return Math.min(Math.max(value, min), max);
}

// node_modules/@svelteuidev/composables/utilities/use-web-worker/lib/jobRunner.js
var jobRunner = (userFunc) => (e) => {
  const userFuncArgs = e.data[0];
  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
    postMessage(["SUCCESS", result]);
  }).catch((error) => {
    postMessage(["ERROR", error]);
  });
};
var jobRunner_default = jobRunner;

// node_modules/@svelteuidev/composables/utilities/use-web-worker/lib/depsParser.js
var depsParser = (deps) => {
  if (deps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  return `importScripts(${depsString})`;
};
var depsParser_default = depsParser;

// node_modules/@svelteuidev/composables/utilities/use-web-worker/lib/createWorkerBlobUrl.js
var createWorkerBlobUrl = (fn, deps) => {
  const blobCode = `${depsParser_default(deps)}; onmessage=(${jobRunner_default})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
};
var createWorkerBlobUrl_default = createWorkerBlobUrl;

// node_modules/@svelteuidev/composables/utilities/use-web-worker/use-web-worker.js
var useWebWorker = (fn, options = {}) => {
  const { dependencies = [], timeout, window: window2 = defaultWindow2 } = options;
  let timeoutId, worker;
  let workerStatus = "PENDING";
  let promise = {};
  const workerTerminate = (status = "PENDING") => {
    if (worker && worker._url && window2) {
      worker.terminate();
      URL.revokeObjectURL(worker._url);
      promise = {};
      worker = void 0;
      window2.clearTimeout(timeoutId);
      workerStatus = status;
    }
  };
  workerTerminate();
  const generateWorker = () => {
    const blobUrl = createWorkerBlobUrl_default(fn, dependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve = () => {
      }, reject = () => {
      } } = promise;
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve(result);
          workerTerminate(status);
          break;
        default:
          reject(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject = () => {
      } } = promise;
      reject(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      timeoutId = setTimeout(() => workerTerminate("TIMEOUT_EXPIRED"), timeout);
    }
    return newWorker;
  };
  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
    promise = {
      resolve,
      reject
    };
    worker && worker.postMessage([[...fnArgs]]);
    workerStatus = "RUNNING";
  });
  const workerFn = (...fnArgs) => {
    if (workerStatus === "RUNNING") {
      console.error("[useWebWorker] You can only run one instance of the worker at a time.");
      return Promise.reject();
    }
    worker = generateWorker();
    return callWorker(...fnArgs);
  };
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
};

// node_modules/@svelteuidev/composables/utilities/use-element-size/use-element-size.js
var defaultState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function useElementSize() {
  const size = writable(defaultState);
  const elementsize = (node) => {
    let frameID = 0;
    const observer2 = browser ? new ResizeObserver((entries) => {
      const entry = entries[0];
      if (entry) {
        cancelAnimationFrame(frameID);
        frameID = requestAnimationFrame(() => {
          size.set(entry.contentRect);
        });
      }
    }) : null;
    observer2.observe(node);
    return {
      destroy: () => {
        observer2.disconnect();
        cancelAnimationFrame(frameID);
      }
    };
  };
  return [size, elementsize];
}
export {
  ENVIRONMENT,
  use_io_config_exports as IoConfig,
  browser,
  clamp,
  clickoutside,
  clipboard,
  createFilterWrapper,
  cssvariable,
  dateTimeString,
  debounceFilter,
  defaultDocument,
  defaultLocation,
  defaultNavigator,
  defaultWindow2 as defaultWindow,
  download,
  focus,
  getHotkeyHandler,
  hotkey,
  io,
  isBoolean,
  isClient,
  isFunction,
  isNumber,
  isObject,
  isString,
  isWindow,
  lazy,
  lockscroll,
  longpress,
  now,
  pageleave,
  persistenttab,
  portal,
  rand,
  randomID,
  sleep,
  tableave,
  throttleFilter,
  timestamp,
  upperFirst,
  useBrowserContext,
  useDebounce,
  useElementSize,
  useEyeDropper,
  useFocusWithin,
  useHash,
  useMousePosition,
  useOs,
  useRafFn,
  useRegexFactory,
  useThrottle,
  useViewportSize,
  useWebWorker
};
//# sourceMappingURL=@svelteuidev_composables.js.map
