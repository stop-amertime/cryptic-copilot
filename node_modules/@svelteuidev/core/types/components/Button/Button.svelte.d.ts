import { SvelteComponentTyped } from "svelte";
declare const __propDef: {
    props: {
        class?: string;
        use?: import("../../internal/utils/forwarding/forward-actions").ActionArray;
        element?: HTMLButtonElement | HTMLAnchorElement;
        className?: string;
        override?: import("../..").CSS;
        variant?: import("./Button.styles").ButtonVariant;
        color?: import("../..").SvelteUIColor;
        size?: import("../..").SvelteUINumberSize;
        radius?: number | import("../..").SvelteUINumberSize;
        gradient?: import("../..").SvelteUIGradient;
        loaderPosition?: "left" | "right";
        loaderProps?: import("./Button.styles").LoaderProps;
        href?: string;
        external?: boolean;
        disabled?: boolean;
        compact?: boolean;
        loading?: boolean;
        uppercase?: boolean;
        fullSize?: boolean;
        ripple?: boolean;
        form?: HTMLFormElement;
        formAction?: string;
        formEnctype?: string;
        formMethod?: string;
        formNoValidate?: boolean;
        formTarget?: string;
        labels?: NodeListOf<HTMLLabelElement>;
        name?: string;
        type?: string;
        validationMessage?: string;
        validity?: ValidityState;
        value?: string;
        willValidate?: boolean;
        checkValidity?: () => boolean;
        reportValidity?: () => boolean;
        setCustomValidity?: (error: string) => void;
        addEventListener?: {
            <K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLButtonElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        };
        removeEventListener?: {
            <K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLButtonElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        };
        accessKey?: string;
        accessKeyLabel?: string;
        autocapitalize?: string;
        dir?: string;
        draggable?: boolean;
        hidden?: boolean;
        innerText?: string;
        lang?: string;
        offsetHeight?: number;
        offsetLeft?: number;
        offsetParent?: Element;
        offsetTop?: number;
        offsetWidth?: number;
        outerText?: string;
        spellcheck?: boolean;
        title?: string;
        translate?: boolean;
        attachInternals?: () => ElementInternals;
        click?: () => void;
        attributes?: NamedNodeMap;
        classList?: DOMTokenList;
        clientHeight?: number;
        clientLeft?: number;
        clientTop?: number;
        clientWidth?: number;
        id?: string;
        localName?: string;
        namespaceURI?: string;
        onfullscreenchange?: (this: Element, ev: Event) => any;
        onfullscreenerror?: (this: Element, ev: Event) => any;
        outerHTML?: string;
        ownerDocument?: Document;
        part?: DOMTokenList;
        prefix?: string;
        scrollHeight?: number;
        scrollLeft?: number;
        scrollTop?: number;
        scrollWidth?: number;
        shadowRoot?: ShadowRoot;
        slot?: string;
        tagName?: string;
        attachShadow?: (init: ShadowRootInit) => ShadowRoot;
        closest?: {
            <K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
            <K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
            <E extends Element = Element>(selectors: string): E;
        };
        getAttribute?: (qualifiedName: string) => string;
        getAttributeNS?: (namespace: string, localName: string) => string;
        getAttributeNames?: () => string[];
        getAttributeNode?: (qualifiedName: string) => Attr;
        getAttributeNodeNS?: (namespace: string, localName: string) => Attr;
        getBoundingClientRect?: () => DOMRect;
        getClientRects?: () => DOMRectList;
        getElementsByClassName?: (classNames: string) => HTMLCollectionOf<Element>;
        getElementsByTagName?: {
            <K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
            <K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        };
        getElementsByTagNameNS?: {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        };
        hasAttribute?: (qualifiedName: string) => boolean;
        hasAttributeNS?: (namespace: string, localName: string) => boolean;
        hasAttributes?: () => boolean;
        hasPointerCapture?: (pointerId: number) => boolean;
        insertAdjacentElement?: (where: InsertPosition, element: Element) => Element;
        insertAdjacentHTML?: (position: InsertPosition, text: string) => void;
        insertAdjacentText?: (where: InsertPosition, data: string) => void;
        matches?: (selectors: string) => boolean;
        releasePointerCapture?: (pointerId: number) => void;
        removeAttribute?: (qualifiedName: string) => void;
        removeAttributeNS?: (namespace: string, localName: string) => void;
        removeAttributeNode?: (attr: Attr) => Attr;
        requestFullscreen?: (options?: FullscreenOptions) => Promise<void>;
        requestPointerLock?: () => void;
        scroll?: {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        };
        scrollBy?: {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        };
        scrollIntoView?: (arg?: boolean | ScrollIntoViewOptions) => void;
        scrollTo?: {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        };
        setAttribute?: (qualifiedName: string, value: string) => void;
        setAttributeNS?: (namespace: string, qualifiedName: string, value: string) => void;
        setAttributeNode?: (attr: Attr) => Attr;
        setAttributeNodeNS?: (attr: Attr) => Attr;
        setPointerCapture?: (pointerId: number) => void;
        toggleAttribute?: (qualifiedName: string, force?: boolean) => boolean;
        webkitMatchesSelector?: (selectors: string) => boolean;
        baseURI?: string;
        childNodes?: NodeListOf<ChildNode>;
        firstChild?: ChildNode;
        isConnected?: boolean;
        lastChild?: ChildNode;
        nextSibling?: ChildNode;
        nodeName?: string;
        nodeType?: number;
        nodeValue?: string;
        parentElement?: HTMLElement;
        parentNode?: ParentNode;
        previousSibling?: ChildNode;
        textContent?: string;
        appendChild?: <T extends Node>(node: T) => T;
        cloneNode?: (deep?: boolean) => Node;
        compareDocumentPosition?: (other: Node) => number;
        contains?: (other: Node) => boolean;
        getRootNode?: (options?: GetRootNodeOptions) => Node;
        hasChildNodes?: () => boolean;
        insertBefore?: <T_1 extends Node>(node: T_1, child: Node) => T_1;
        isDefaultNamespace?: (namespace: string) => boolean;
        isEqualNode?: (otherNode: Node) => boolean;
        isSameNode?: (otherNode: Node) => boolean;
        lookupNamespaceURI?: (prefix: string) => string;
        lookupPrefix?: (namespace: string) => string;
        normalize?: () => void;
        removeChild?: <T_2 extends Node>(child: T_2) => T_2;
        replaceChild?: <T_3 extends Node>(node: Node, child: T_3) => T_3;
        ATTRIBUTE_NODE?: number;
        CDATA_SECTION_NODE?: number;
        COMMENT_NODE?: number;
        DOCUMENT_FRAGMENT_NODE?: number;
        DOCUMENT_NODE?: number;
        DOCUMENT_POSITION_CONTAINED_BY?: number;
        DOCUMENT_POSITION_CONTAINS?: number;
        DOCUMENT_POSITION_DISCONNECTED?: number;
        DOCUMENT_POSITION_FOLLOWING?: number;
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC?: number;
        DOCUMENT_POSITION_PRECEDING?: number;
        DOCUMENT_TYPE_NODE?: number;
        ELEMENT_NODE?: number;
        ENTITY_NODE?: number;
        ENTITY_REFERENCE_NODE?: number;
        NOTATION_NODE?: number;
        PROCESSING_INSTRUCTION_NODE?: number;
        TEXT_NODE?: number;
        dispatchEvent?: (event: Event) => boolean;
        ariaAtomic?: string;
        ariaAutoComplete?: string;
        ariaBusy?: string;
        ariaChecked?: string;
        ariaColCount?: string;
        ariaColIndex?: string;
        ariaColSpan?: string;
        ariaCurrent?: string;
        ariaDisabled?: string;
        ariaExpanded?: string;
        ariaHasPopup?: string;
        ariaHidden?: string;
        ariaKeyShortcuts?: string;
        ariaLabel?: string;
        ariaLevel?: string;
        ariaLive?: string;
        ariaModal?: string;
        ariaMultiLine?: string;
        ariaMultiSelectable?: string;
        ariaOrientation?: string;
        ariaPlaceholder?: string;
        ariaPosInSet?: string;
        ariaPressed?: string;
        ariaReadOnly?: string;
        ariaRequired?: string;
        ariaRoleDescription?: string;
        ariaRowCount?: string;
        ariaRowIndex?: string;
        ariaRowSpan?: string;
        ariaSelected?: string;
        ariaSetSize?: string;
        ariaSort?: string;
        ariaValueMax?: string;
        ariaValueMin?: string;
        ariaValueNow?: string;
        ariaValueText?: string;
        animate?: (keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions) => Animation;
        getAnimations?: (options?: GetAnimationsOptions) => Animation[];
        after?: (...nodes: (string | Node)[]) => void;
        before?: (...nodes: (string | Node)[]) => void;
        remove?: () => void;
        replaceWith?: (...nodes: (string | Node)[]) => void;
        innerHTML?: string;
        nextElementSibling?: Element;
        previousElementSibling?: Element;
        childElementCount?: number;
        children?: HTMLCollection;
        firstElementChild?: Element;
        lastElementChild?: Element;
        append?: (...nodes: (string | Node)[]) => void;
        prepend?: (...nodes: (string | Node)[]) => void;
        querySelector?: {
            <K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
            <K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
            <E_1 extends Element = Element>(selectors: string): E_1;
        };
        querySelectorAll?: {
            <K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
            <K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
            <E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
        };
        replaceChildren?: (...nodes: (string | Node)[]) => void;
        assignedSlot?: HTMLSlotElement;
        oncopy?: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
        oncut?: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
        onpaste?: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
        style?: CSSStyleDeclaration;
        contentEditable?: string;
        enterKeyHint?: string;
        inputMode?: string;
        isContentEditable?: boolean;
        onabort?: (this: GlobalEventHandlers, ev: UIEvent) => any;
        onanimationcancel?: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onanimationend?: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onanimationiteration?: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onanimationstart?: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onauxclick?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onblur?: (this: GlobalEventHandlers, ev: FocusEvent) => any;
        oncanplay?: (this: GlobalEventHandlers, ev: Event) => any;
        oncanplaythrough?: (this: GlobalEventHandlers, ev: Event) => any;
        onchange?: (this: GlobalEventHandlers, ev: Event) => any;
        onclick?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onclose?: (this: GlobalEventHandlers, ev: Event) => any;
        oncontextmenu?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        oncuechange?: (this: GlobalEventHandlers, ev: Event) => any;
        ondblclick?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        ondrag?: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragend?: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragenter?: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragleave?: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragover?: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragstart?: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondrop?: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondurationchange?: (this: GlobalEventHandlers, ev: Event) => any;
        onemptied?: (this: GlobalEventHandlers, ev: Event) => any;
        onended?: (this: GlobalEventHandlers, ev: Event) => any;
        onerror?: OnErrorEventHandlerNonNull;
        onfocus?: (this: GlobalEventHandlers, ev: FocusEvent) => any;
        onformdata?: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
        ongotpointercapture?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        oninput?: (this: GlobalEventHandlers, ev: Event) => any;
        oninvalid?: (this: GlobalEventHandlers, ev: Event) => any;
        onkeydown?: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
        onkeypress?: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
        onkeyup?: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
        onload?: (this: GlobalEventHandlers, ev: Event) => any;
        onloadeddata?: (this: GlobalEventHandlers, ev: Event) => any;
        onloadedmetadata?: (this: GlobalEventHandlers, ev: Event) => any;
        onloadstart?: (this: GlobalEventHandlers, ev: Event) => any;
        onlostpointercapture?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onmousedown?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseenter?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseleave?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmousemove?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseout?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseover?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseup?: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onpause?: (this: GlobalEventHandlers, ev: Event) => any;
        onplay?: (this: GlobalEventHandlers, ev: Event) => any;
        onplaying?: (this: GlobalEventHandlers, ev: Event) => any;
        onpointercancel?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerdown?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerenter?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerleave?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointermove?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerout?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerover?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerup?: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onprogress?: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
        onratechange?: (this: GlobalEventHandlers, ev: Event) => any;
        onreset?: (this: GlobalEventHandlers, ev: Event) => any;
        onresize?: (this: GlobalEventHandlers, ev: UIEvent) => any;
        onscroll?: (this: GlobalEventHandlers, ev: Event) => any;
        onsecuritypolicyviolation?: (this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any;
        onseeked?: (this: GlobalEventHandlers, ev: Event) => any;
        onseeking?: (this: GlobalEventHandlers, ev: Event) => any;
        onselect?: (this: GlobalEventHandlers, ev: Event) => any;
        onselectionchange?: (this: GlobalEventHandlers, ev: Event) => any;
        onselectstart?: (this: GlobalEventHandlers, ev: Event) => any;
        onslotchange?: (this: GlobalEventHandlers, ev: Event) => any;
        onstalled?: (this: GlobalEventHandlers, ev: Event) => any;
        onsubmit?: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
        onsuspend?: (this: GlobalEventHandlers, ev: Event) => any;
        ontimeupdate?: (this: GlobalEventHandlers, ev: Event) => any;
        ontoggle?: (this: GlobalEventHandlers, ev: Event) => any;
        ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontransitioncancel?: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        ontransitionend?: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        ontransitionrun?: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        ontransitionstart?: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        onvolumechange?: (this: GlobalEventHandlers, ev: Event) => any;
        onwaiting?: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkitanimationend?: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkitanimationiteration?: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkitanimationstart?: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkittransitionend?: (this: GlobalEventHandlers, ev: Event) => any;
        onwheel?: (this: GlobalEventHandlers, ev: WheelEvent) => any;
        autofocus?: boolean;
        dataset?: DOMStringMap;
        nonce?: string;
        tabIndex?: number;
        blur?: () => void;
        focus?: (options?: FocusOptions) => void;
        never?: never;
    };
    events: {
        [evt: string]: CustomEvent<any>;
    };
    slots: {
        leftIcon: {};
        default: {};
        rightIcon: {};
    };
};
export declare type ButtonProps = typeof __propDef.props;
export declare type ButtonEvents = typeof __propDef.events;
export declare type ButtonSlots = typeof __propDef.slots;
/**
 * A user can perform an immediate action by pressing a button. It's frequently used to start an action, but it can also be used to link to other pages.
 *
 * @see https://svelteui.org/core/button
 * @example
 * ```tsx
 * <Button>Click</Button> // standard button
 * <Button variant='gradient' gradient={{from: 'blue', to: 'red', deg: 45}}>Click Me</Button> // gradient button
 * ```
 */
export default class Button extends SvelteComponentTyped<ButtonProps, ButtonEvents, ButtonSlots> {
}
export {};
