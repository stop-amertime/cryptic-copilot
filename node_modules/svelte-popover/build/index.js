(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Popover = factory());
}(this, function () { 'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function create_slot(definition, ctx, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
            : ctx.$$scope.ctx;
    }
    function get_slot_changes(definition, ctx, changed, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
            : ctx.$$scope.changed || {};
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
        const component = current_component;
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment) {
            $$.update($$.dirty);
            run_all($$.before_update);
            $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        if (component.$$.fragment) {
            run_all(component.$$.on_destroy);
            component.$$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            component.$$.on_destroy = component.$$.fragment = null;
            component.$$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal, prop_names) {
        const parent_component = current_component;
        set_current_component(component);
        const props = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props: prop_names,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, props, (key, ret, value = ret) => {
                if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
                return ret;
            })
            : props;
        $$.update();
        ready = true;
        run_all($$.before_update);
        $$.fragment = create_fragment($$.ctx);
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    /* src/Overlay.svelte generated by Svelte v3.12.1 */

    function add_css() {
    	var style = element("style");
    	style.id = 'svelte-s1nj9q-style';
    	style.textContent = ".overlay.svelte-s1nj9q{position:fixed;width:100%;height:100%;top:0;left:0;cursor:pointer}";
    	append(document.head, style);
    }

    function create_fragment(ctx) {
    	var div, dispose;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "id", "overlay");
    			attr(div, "class", "overlay svelte-s1nj9q");
    			set_style(div, "z-index", ctx.zIndex);
    			set_style(div, "background-color", ctx.overlayColor);

    			dispose = [
    				listen(div, "mouseenter", ctx.onMouseEnter),
    				listen(div, "click", ctx.onClick),
    				listen(div, "touchend", ctx.onTouchEnd)
    			];
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p(changed, ctx) {
    			if (changed.zIndex) {
    				set_style(div, "z-index", ctx.zIndex);
    			}

    			if (changed.overlayColor) {
    				set_style(div, "background-color", ctx.overlayColor);
    			}
    		},

    		i: noop,
    		o: noop,

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			run_all(dispose);
    		}
    	};
    }

    function instance($$self, $$props, $$invalidate) {
    	let { zIndex, action, overlayColor = 'rgba(0,0,0,0.5)', preventDefault, stopPropagation } = $$props;

      const dispatch = createEventDispatcher();

      const eventClick = e => {
        if (preventDefault) e.preventDefault();
        if (stopPropagation) e.stopPropagation();

        dispatch('setOpen', {});
      };

      const onClick = action === 'click' ? eventClick : null;
      const onTouchEnd = action === 'click' ? eventClick : null;

      const onMouseEnter = action === 'hover' ? eventClick : null;

    	$$self.$set = $$props => {
    		if ('zIndex' in $$props) $$invalidate('zIndex', zIndex = $$props.zIndex);
    		if ('action' in $$props) $$invalidate('action', action = $$props.action);
    		if ('overlayColor' in $$props) $$invalidate('overlayColor', overlayColor = $$props.overlayColor);
    		if ('preventDefault' in $$props) $$invalidate('preventDefault', preventDefault = $$props.preventDefault);
    		if ('stopPropagation' in $$props) $$invalidate('stopPropagation', stopPropagation = $$props.stopPropagation);
    	};

    	return {
    		zIndex,
    		action,
    		overlayColor,
    		preventDefault,
    		stopPropagation,
    		onClick,
    		onTouchEnd,
    		onMouseEnter
    	};
    }

    class Overlay extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-s1nj9q-style")) add_css();
    		init(this, options, instance, create_fragment, safe_not_equal, ["zIndex", "action", "overlayColor", "preventDefault", "stopPropagation"]);
    	}
    }

    /* src/Content.svelte generated by Svelte v3.12.1 */

    function add_css$1() {
    	var style = element("style");
    	style.id = 'svelte-d75kyr-style';
    	style.textContent = ".arrow.svelte-d75kyr{position:absolute;top:0}.content.svelte-d75kyr{display:inline-block;position:absolute;left:0;top:0}";
    	append(document.head, style);
    }

    // (16:2) {#if arrow}
    function create_if_block(ctx) {
    	var div, t, div_style_value;

    	return {
    		c() {
    			div = element("div");
    			t = text("◥");
    			attr(div, "class", "arrow svelte-d75kyr");
    			attr(div, "style", div_style_value = "position: absolute; color: " + ctx.arrowColor + "; " + ctx.arrowStyleProps);
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t);
    			ctx.div_binding(div);
    		},

    		p(changed, ctx) {
    			if ((changed.arrowColor || changed.arrowStyleProps) && div_style_value !== (div_style_value = "position: absolute; color: " + ctx.arrowColor + "; " + ctx.arrowStyleProps)) {
    				attr(div, "style", div_style_value);
    			}
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			ctx.div_binding(null);
    		}
    	};
    }

    function create_fragment$1(ctx) {
    	var div, t0, div_style_value, t1, current;

    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	var if_block = (ctx.arrow) && create_if_block(ctx);

    	var overlay = new Overlay({
    		props: {
    		zIndex: ctx.zIndex,
    		overlayColor: ctx.overlayColor,
    		action: ctx.action,
    		stopPropagation: ctx.stopPropagation,
    		preventDefault: ctx.preventDefault
    	}
    	});
    	overlay.$on("setOpen", ctx.setOpen);

    	return {
    		c() {
    			div = element("div");

    			if (default_slot) default_slot.c();
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			overlay.$$.fragment.c();

    			attr(div, "class", "content svelte-d75kyr");
    			attr(div, "style", div_style_value = "z-index: " + (ctx.zIndex + 10) + "; " + ctx.positionStyle);
    		},

    		l(nodes) {
    			if (default_slot) default_slot.l(div_nodes);
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append(div, t0);
    			if (if_block) if_block.m(div, null);
    			ctx.div_binding_1(div);
    			insert(target, t1, anchor);
    			mount_component(overlay, target, anchor);
    			current = true;
    		},

    		p(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(
    					get_slot_changes(default_slot_template, ctx, changed, null),
    					get_slot_context(default_slot_template, ctx, null)
    				);
    			}

    			if (ctx.arrow) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((!current || changed.zIndex || changed.positionStyle) && div_style_value !== (div_style_value = "z-index: " + (ctx.zIndex + 10) + "; " + ctx.positionStyle)) {
    				attr(div, "style", div_style_value);
    			}

    			var overlay_changes = {};
    			if (changed.zIndex) overlay_changes.zIndex = ctx.zIndex;
    			if (changed.overlayColor) overlay_changes.overlayColor = ctx.overlayColor;
    			if (changed.action) overlay_changes.action = ctx.action;
    			if (changed.stopPropagation) overlay_changes.stopPropagation = ctx.stopPropagation;
    			if (changed.preventDefault) overlay_changes.preventDefault = ctx.preventDefault;
    			overlay.$set(overlay_changes);
    		},

    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			transition_in(overlay.$$.fragment, local);

    			current = true;
    		},

    		o(local) {
    			transition_out(default_slot, local);
    			transition_out(overlay.$$.fragment, local);
    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			ctx.div_binding_1(null);

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(overlay, detaching);
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { arrowColor, targetRef, zIndex, arrow, placement, action, preventDefault, stopPropagation, overlayColor } = $$props;

      let contentRef;
      let arrowRef;
      let positionStyle = ``;
      let arrowStyleProps = ``;

      const dispatch = createEventDispatcher();

      const setOpen = () => {
        dispatch('setOpen', {});
      };

      const calculate = () => {
        const targetBound = targetRef.getBoundingClientRect();
        const contentBound = contentRef.getBoundingClientRect();

        let arrowBound = { width: 0, height: 0 };
        if (arrow) {
          arrowBound = arrowRef.getBoundingClientRect();
        }

        const { innerWidth, innerHeight } = window;

        const calcCoverLeft = contentBound.x - contentBound.width;
        const coverLeft = calcCoverLeft < 0 ? calcCoverLeft : 0;

        const calcCoverRight = contentBound.x + targetBound.width + contentBound.width;
        const coverRight = calcCoverRight > innerWidth ? innerWidth - calcCoverRight : 0;

        const calcCoverTop = contentBound.y - contentBound.height;
        const coverTop = calcCoverTop < 0 ? calcCoverTop : 0;

        const calcCoverBottom = targetBound.bottom + contentBound.height;
        const coverBottom = calcCoverBottom > innerHeight ? innerHeight - calcCoverBottom : 0;

        const calcXCenterLeft = contentBound.x + targetBound.width / 2 - contentBound.width / 2;

        const calcXCenterRight = contentBound.x + targetBound.width / 2 - contentBound.width / 2 + contentBound.width;

        const coverXCenterLeft = calcXCenterLeft < 0 ? calcXCenterLeft : 0;

        const coverXCenterRight = calcXCenterRight > innerWidth ? innerWidth - calcXCenterRight : 0;

        const calcYCenterTop = contentBound.y + targetBound.height / 2 - contentBound.height / 2;

        const coverYCenterTop = calcYCenterTop < 0 ? calcYCenterTop : 0;

        const calcYCenterBottom = contentBound.y + targetBound.height / 2 - contentBound.height / 2 + contentBound.height;

        const coverYCenterBottom = calcYCenterBottom > innerHeight ? calcYCenterBottom : 0;

        const calcTopStart = contentBound.x + contentBound.width;
        const coverTopStart = calcTopStart > innerWidth ? innerWidth - calcTopStart : 0;

        const calcTopEnd = contentBound.x - (contentBound.width - targetBound.width);
        const coverTopEnd = calcTopEnd < 0 ? calcTopEnd : 0;

        const calcLeftEndTop = contentBound.y - (contentBound.height - targetBound.height);
        const coverLeftEndTop = calcLeftEndTop < 0 ? calcLeftEndTop : 0;

        const coverRightEndTop = coverLeftEndTop;

        const calcLefStartBottom = contentBound.y + contentBound.height;
        const coverLeftStartBottom = calcLefStartBottom > innerHeight ? innerHeight - calcLefStartBottom : 0;

        const coverRightStartBottom = coverLeftStartBottom;

        const coverBottomStartRight = coverTopStart;
        const coverBottomEndLeft = coverTopEnd;

        const xCenterStyle = targetBound.height / 2 - contentBound.height / 2;
        const rightLeftEnd = -(contentBound.height - targetBound.height);
        const topBottomEnd = -(contentBound.width - targetBound.width);
        const topBottomCenter = targetBound.width / 2 - contentBound.width / 2;

        const computeArrowW = arrowBound.width / 2;
        const computearrowH = arrowBound.height / 2;

        const leftLeftStyle = -(contentBound.width + computeArrowW);
        const topTopStyle = -(contentBound.height + arrowBound.height / 2);
        const rightLeftStyle = targetBound.width + computeArrowW;
        const bottomTopStyle = targetBound.height + computearrowH;

        const styles = {
          topStart: `top:${topTopStyle}px`,
          topCenter: `top:${topTopStyle}px;left:${topBottomCenter}px`,
          topEnd: `top:${topTopStyle}px;left:${topBottomEnd}px`,

          leftStart: `left:${leftLeftStyle}px`,
          leftCenter: `left:${leftLeftStyle}px;top:${xCenterStyle}px`,
          leftEnd: `left:${leftLeftStyle}px;top:${rightLeftEnd}px`,

          rightStart: `left:${rightLeftStyle}px`,
          rightCenter: `left:${rightLeftStyle}px;top:${xCenterStyle}px`,
          rightEnd: `left:${rightLeftStyle}px;top:${rightLeftEnd}px`,

          bottomStart: `top:${bottomTopStyle}px`,
          bottomCenter: `top:${bottomTopStyle}px;left:${topBottomCenter}px`,
          bottomEnd: `top:${bottomTopStyle}px;left:${topBottomEnd}px;`,
        };

        const arrowBottomTransform = `transform:rotate(-45deg)`;
        const arrowTopTransform = `transform: rotate(135deg)`;
        const arrowLeftTransform = `transform: rotate(45deg)`;
        const arrowRightTransform = `transform:rotate(45deg)`;

        const arrowBottomTop = Math.ceil(-arrowBound.height / 2);

        const arrowBottomTopCenter = contentBound.width / 2 - arrowBound.width / 2;

        const arrowTop = contentBound.height - arrowBound.height / 2;
        const arrowTopBottomEnd = targetBound.width / 2 - arrowBound.width / 2;

        const arrowLeftRightEnd = contentBound.height - arrowBound.height / 2 - targetBound.height / 2;

        const arrowLeftRightCenter = contentBound.height / 2 - Math.ceil(arrowBound.height / 2);
        const arrowTopBottomStartLeft = targetBound.width / 2 - arrowBound.width / 2;

        const arrowLeftLeft = Math.ceil(contentBound.width - arrowBound.width / 2);
        const arrowLeftRightTop = targetBound.height / 2 - arrowBound.height / 2;

        const arrowStyle = {
          topStart: `${arrowTopTransform};top:${arrowTop}px;left:${arrowTopBottomStartLeft}px`,
          topCenter: `${arrowTopTransform};top:${arrowTop}px;left:${arrowBottomTopCenter}px`,
          topEnd: `${arrowTopTransform};top:${arrowTop}px;right:${arrowTopBottomEnd}px`,

          leftStart: `${arrowLeftTransform};left:${arrowLeftLeft}px;top:${arrowLeftRightTop}px`,

          leftCenter: `${arrowLeftTransform};left:${arrowLeftLeft}px;top:${arrowLeftRightCenter}px`,

          leftEnd: `${arrowLeftTransform};left:${arrowLeftLeft}px;top:${arrowLeftRightEnd}px`,

          rightStart: `${arrowRightTransform};left:${-arrowBound.width}px;top:${arrowLeftRightTop}px`,

          rightCenter: `${arrowRightTransform};left:${-arrowBound.width}px;top:${arrowLeftRightCenter}px`,

          rightEnd: `${arrowRightTransform};left:${-arrowBound.width}px;top:${arrowLeftRightEnd}px`,

          bottomStart: `${arrowBottomTransform};top:${arrowBottomTop}px;left:${arrowTopBottomStartLeft}px`,
          bottomCenter: `${arrowBottomTransform};top:${arrowBottomTop}px;left:${arrowBottomTopCenter}px`,
          bottomEnd: `${arrowBottomTransform};top:${arrowBottomTop}px;right:${arrowTopBottomEnd}px`,
        };

        const pos = [
          {
            at: 'top-start',
            cover: [coverTop, coverTopStart, 0],
            style: styles.topStart,
            arrow: arrowStyle.topStart,
          },
          {
            at: 'top-center',
            cover: [coverTop, coverXCenterLeft, coverXCenterRight],
            style: styles.topCenter,
            arrow: arrowStyle.topCenter,
          },
          {
            at: 'top-end',
            cover: [coverTop, coverTopEnd, 0],
            style: styles.topEnd,
            arrow: arrowStyle.topEnd,
          },
          {
            at: 'left-start',
            cover: [coverLeft, coverLeftStartBottom, 0],
            style: styles.leftStart,
            arrow: arrowStyle.leftStart,
          },
          {
            at: 'left-center',
            cover: [coverLeft, coverYCenterTop, coverYCenterBottom],
            style: styles.leftCenter,
            arrow: arrowStyle.leftCenter,
          },
          {
            at: 'left-end',
            cover: [coverLeft, coverLeftEndTop, 0],
            style: styles.leftEnd,
            arrow: arrowStyle.leftEnd,
          },
          {
            at: 'right-start',
            cover: [coverRight, coverRightStartBottom, 0],
            style: styles.rightStart,
            arrow: arrowStyle.rightStart,
          },
          {
            at: 'right-center',
            cover: [coverRight, coverYCenterTop, coverYCenterBottom],
            style: styles.rightCenter,
            arrow: arrowStyle.rightCenter,
          },
          {
            at: 'right-end',
            cover: [coverRight, coverRightEndTop, 0],
            style: styles.rightEnd,
            arrow: arrowStyle.rightEnd,
          },
          {
            at: 'bottom-start',
            cover: [coverBottom, coverBottomStartRight, 0],
            style: styles.bottomStart,
            arrow: arrowStyle.bottomStart,
          },
          {
            at: 'bottom-center',
            cover: [coverBottom, coverXCenterLeft, coverXCenterRight],
            style: styles.bottomCenter,
            arrow: arrowStyle.bottomCenter,
          },
          {
            at: 'bottom-end',
            cover: [coverBottom, coverBottomEndLeft, 0],
            style: styles.bottomEnd,
            arrow: arrowStyle.bottomEnd,
          },
        ];

        let get;

        if (placement === 'auto') {
          const reducer = (accumulator, currentValue) => accumulator + currentValue;

          const compute = pos.map(({ cover }) => cover.reduce(reducer));
          const findIndex = compute.indexOf(Math.max(...compute));
          const result = pos[findIndex];
          get = result;
        } else {
          get = pos.filter(val => val.at === placement)[0];
        }
        const debug = pos.map(val => val.cover);

        $$invalidate('positionStyle', positionStyle = get.style);
        $$invalidate('arrowStyleProps', arrowStyleProps = get.arrow);
      };

      onMount(() => {
        calculate();

        dispatch('open');
      });

    	let { $$slots = {}, $$scope } = $$props;

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('arrowRef', arrowRef = $$value);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('contentRef', contentRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('arrowColor' in $$props) $$invalidate('arrowColor', arrowColor = $$props.arrowColor);
    		if ('targetRef' in $$props) $$invalidate('targetRef', targetRef = $$props.targetRef);
    		if ('zIndex' in $$props) $$invalidate('zIndex', zIndex = $$props.zIndex);
    		if ('arrow' in $$props) $$invalidate('arrow', arrow = $$props.arrow);
    		if ('placement' in $$props) $$invalidate('placement', placement = $$props.placement);
    		if ('action' in $$props) $$invalidate('action', action = $$props.action);
    		if ('preventDefault' in $$props) $$invalidate('preventDefault', preventDefault = $$props.preventDefault);
    		if ('stopPropagation' in $$props) $$invalidate('stopPropagation', stopPropagation = $$props.stopPropagation);
    		if ('overlayColor' in $$props) $$invalidate('overlayColor', overlayColor = $$props.overlayColor);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return {
    		arrowColor,
    		targetRef,
    		zIndex,
    		arrow,
    		placement,
    		action,
    		preventDefault,
    		stopPropagation,
    		overlayColor,
    		contentRef,
    		arrowRef,
    		positionStyle,
    		arrowStyleProps,
    		setOpen,
    		div_binding,
    		div_binding_1,
    		$$slots,
    		$$scope
    	};
    }

    class Content extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-d75kyr-style")) add_css$1();
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["arrowColor", "targetRef", "zIndex", "arrow", "placement", "action", "preventDefault", "stopPropagation", "overlayColor"]);
    	}
    }

    /* src/index.svelte generated by Svelte v3.12.1 */

    function add_css$2() {
    	var style = element("style");
    	style.id = 'svelte-555tz3-style';
    	style.textContent = ".target.svelte-555tz3{display:inline-block;position:relative}.popover.svelte-555tz3{position:relative}";
    	append(document.head, style);
    }

    const get_content_slot_changes = ({ open }) => ({ open: open });
    const get_content_slot_context = ({ open }) => ({ open: open });

    const get_target_slot_changes = ({ open }) => ({ open: open });
    const get_target_slot_context = ({ open }) => ({ open: open });

    // (15:2) {#if open}
    function create_if_block$1(ctx) {
    	var current;

    	var content = new Content({
    		props: {
    		placement: ctx.placement,
    		targetRef: ctx.targetRef,
    		zIndex: ctx.zIndex,
    		arrow: ctx.arrow,
    		action: ctx.action,
    		overlayColor: ctx.overlayColor,
    		arrowColor: ctx.arrowColor,
    		preventDefault: ctx.preventDefault,
    		stopPropagation: ctx.stopPropagation,
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	}
    	});
    	content.$on("open", ctx.onOpen);
    	content.$on("setOpen", ctx.setOpen);

    	return {
    		c() {
    			content.$$.fragment.c();
    		},

    		m(target, anchor) {
    			mount_component(content, target, anchor);
    			current = true;
    		},

    		p(changed, ctx) {
    			var content_changes = {};
    			if (changed.placement) content_changes.placement = ctx.placement;
    			if (changed.targetRef) content_changes.targetRef = ctx.targetRef;
    			if (changed.zIndex) content_changes.zIndex = ctx.zIndex;
    			if (changed.arrow) content_changes.arrow = ctx.arrow;
    			if (changed.action) content_changes.action = ctx.action;
    			if (changed.overlayColor) content_changes.overlayColor = ctx.overlayColor;
    			if (changed.arrowColor) content_changes.arrowColor = ctx.arrowColor;
    			if (changed.preventDefault) content_changes.preventDefault = ctx.preventDefault;
    			if (changed.stopPropagation) content_changes.stopPropagation = ctx.stopPropagation;
    			if (changed.$$scope || changed.open) content_changes.$$scope = { changed, ctx };
    			content.$set(content_changes);
    		},

    		i(local) {
    			if (current) return;
    			transition_in(content.$$.fragment, local);

    			current = true;
    		},

    		o(local) {
    			transition_out(content.$$.fragment, local);
    			current = false;
    		},

    		d(detaching) {
    			destroy_component(content, detaching);
    		}
    	};
    }

    // (16:4) <Content on:open={onOpen} on:setOpen={setOpen} {placement} {targetRef} {zIndex} {arrow} {action} {overlayColor} {arrowColor} {preventDefault} {stopPropagation}>
    function create_default_slot(ctx) {
    	var current;

    	const content_slot_template = ctx.$$slots.content;
    	const content_slot = create_slot(content_slot_template, ctx, get_content_slot_context);

    	return {
    		c() {
    			if (content_slot) content_slot.c();
    		},

    		l(nodes) {
    			if (content_slot) content_slot.l(nodes);
    		},

    		m(target, anchor) {
    			if (content_slot) {
    				content_slot.m(target, anchor);
    			}

    			current = true;
    		},

    		p(changed, ctx) {
    			if (content_slot && content_slot.p && (changed.$$scope || changed.open)) {
    				content_slot.p(
    					get_slot_changes(content_slot_template, ctx, changed, get_content_slot_changes),
    					get_slot_context(content_slot_template, ctx, get_content_slot_context)
    				);
    			}
    		},

    		i(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			current = true;
    		},

    		o(local) {
    			transition_out(content_slot, local);
    			current = false;
    		},

    		d(detaching) {
    			if (content_slot) content_slot.d(detaching);
    		}
    	};
    }

    function create_fragment$2(ctx) {
    	var div1, div0, div0_style_value, t, current, dispose;

    	const target_slot_template = ctx.$$slots.target;
    	const target_slot = create_slot(target_slot_template, ctx, get_target_slot_context);

    	var if_block = (ctx.open) && create_if_block$1(ctx);

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");

    			if (target_slot) target_slot.c();
    			t = space();
    			if (if_block) if_block.c();

    			attr(div0, "class", "target svelte-555tz3");
    			attr(div0, "style", div0_style_value = ctx.open ? `z-index: ${ctx.zIndex + 10}` : '');
    			attr(div1, "class", "popover svelte-555tz3");

    			dispose = [
    				listen(div0, "click", ctx.onClick),
    				listen(div0, "touchend", ctx.onTouchEnd),
    				listen(div0, "mouseover", ctx.onMouseOver),
    				listen(div0, "mouseout", ctx.onMouseOut)
    			];
    		},

    		l(nodes) {
    			if (target_slot) target_slot.l(div0_nodes);
    		},

    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);

    			if (target_slot) {
    				target_slot.m(div0, null);
    			}

    			ctx.div0_binding(div0);
    			append(div1, t);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},

    		p(changed, ctx) {
    			if (target_slot && target_slot.p && (changed.$$scope || changed.open)) {
    				target_slot.p(
    					get_slot_changes(target_slot_template, ctx, changed, get_target_slot_changes),
    					get_slot_context(target_slot_template, ctx, get_target_slot_context)
    				);
    			}

    			if ((!current || changed.open || changed.zIndex) && div0_style_value !== (div0_style_value = ctx.open ? `z-index: ${ctx.zIndex + 10}` : '')) {
    				attr(div0, "style", div0_style_value);
    			}

    			if (ctx.open) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i(local) {
    			if (current) return;
    			transition_in(target_slot, local);
    			transition_in(if_block);
    			current = true;
    		},

    		o(local) {
    			transition_out(target_slot, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			if (target_slot) target_slot.d(detaching);
    			ctx.div0_binding(null);
    			if (if_block) if_block.d();
    			run_all(dispose);
    		}
    	};
    }

    const DEFAULT_ZINDEX = 1000;

    function instance$2($$self, $$props, $$invalidate) {
    	
      let targetRef;
      const dispatch = createEventDispatcher();

      const onOpen = () => {
        dispatch('open');
      };

      let { action = 'click', zIndex = DEFAULT_ZINDEX, arrow = true, placement = 'auto', arrowColor = '', overlayColor, preventDefault = false, stopPropagation = false, open = false } = $$props;

      const setOpen = () => {
        $$invalidate('open', open = !open);
        if (!open) {
          dispatch('close');
        }
      };
      const eventClick = e => {
        if (preventDefault) e.preventDefault();
        if (stopPropagation) e.stopPropagation();
        setOpen();
      };
      const eventMouseOut = ({ relatedTarget }) => {
        if (relatedTarget.id === 'overlay' && !open) {
          setOpen();
        }
      };

      const onTouchEnd = action === 'click' ? eventClick : null;
      const onClick = action === 'click' ? eventClick : null;

      const setOpenTrue = () => ($$invalidate('open', open = true));

      const onMouseOver = action === 'hover' ? setOpenTrue : null;
      const onMouseOut = action === 'hover' ? eventMouseOut : null;

    	let { $$slots = {}, $$scope } = $$props;

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('targetRef', targetRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('action' in $$props) $$invalidate('action', action = $$props.action);
    		if ('zIndex' in $$props) $$invalidate('zIndex', zIndex = $$props.zIndex);
    		if ('arrow' in $$props) $$invalidate('arrow', arrow = $$props.arrow);
    		if ('placement' in $$props) $$invalidate('placement', placement = $$props.placement);
    		if ('arrowColor' in $$props) $$invalidate('arrowColor', arrowColor = $$props.arrowColor);
    		if ('overlayColor' in $$props) $$invalidate('overlayColor', overlayColor = $$props.overlayColor);
    		if ('preventDefault' in $$props) $$invalidate('preventDefault', preventDefault = $$props.preventDefault);
    		if ('stopPropagation' in $$props) $$invalidate('stopPropagation', stopPropagation = $$props.stopPropagation);
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return {
    		targetRef,
    		onOpen,
    		action,
    		zIndex,
    		arrow,
    		placement,
    		arrowColor,
    		overlayColor,
    		preventDefault,
    		stopPropagation,
    		open,
    		setOpen,
    		onTouchEnd,
    		onClick,
    		onMouseOver,
    		onMouseOut,
    		div0_binding,
    		$$slots,
    		$$scope
    	};
    }

    class Index extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document.getElementById("svelte-555tz3-style")) add_css$2();
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["action", "zIndex", "arrow", "placement", "arrowColor", "overlayColor", "preventDefault", "stopPropagation", "open"]);
    	}
    }

    return Index;

}));
