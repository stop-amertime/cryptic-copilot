"use strict";
const path_1 = require("path");
const language_service_1 = require("./language-service");
const logger_1 = require("./logger");
const module_loader_1 = require("./module-loader");
const svelte_snapshots_1 = require("./svelte-snapshots");
const config_manager_1 = require("./config-manager");
const project_svelte_files_1 = require("./project-svelte-files");
const utils_1 = require("./utils");
function init(modules) {
    const configManager = new config_manager_1.ConfigManager();
    function create(info) {
        var _a, _b, _c, _d;
        const logger = new logger_1.Logger(info.project.projectService.logger);
        if (!isSvelteProject(info.project.getCompilerOptions())) {
            logger.log('Detected that this is not a Svelte project, abort patching TypeScript');
            return info.languageService;
        }
        if ((0, language_service_1.isPatched)(info.languageService)) {
            logger.log('Already patched. Checking tsconfig updates.');
            (_a = project_svelte_files_1.ProjectSvelteFilesManager.getInstance(info.project.getProjectName())) === null || _a === void 0 ? void 0 : _a.updateProjectConfig(info.languageServiceHost);
            return info.languageService;
        }
        configManager.updateConfigFromPluginConfig(info.config);
        if (configManager.getConfig().enable) {
            logger.log('Starting Svelte plugin');
        }
        else {
            logger.log('Svelte plugin disabled');
            logger.log(info.config);
        }
        // This call the ConfiguredProject.getParsedCommandLine
        // where it'll try to load the cached version of the parsedCommandLine
        const parsedCommandLine = (_c = (_b = info.languageServiceHost).getParsedCommandLine) === null || _c === void 0 ? void 0 : _c.call(_b, (0, utils_1.getConfigPathForProject)(info.project));
        const svelteOptions = ((_d = parsedCommandLine === null || parsedCommandLine === void 0 ? void 0 : parsedCommandLine.raw) === null || _d === void 0 ? void 0 : _d.svelteOptions) || { namespace: 'svelteHTML' };
        logger.log('svelteOptions:', svelteOptions);
        logger.debug(parsedCommandLine === null || parsedCommandLine === void 0 ? void 0 : parsedCommandLine.wildcardDirectories);
        const snapshotManager = new svelte_snapshots_1.SvelteSnapshotManager(modules.typescript, info.project.projectService, svelteOptions, logger, configManager);
        const projectSvelteFilesManager = parsedCommandLine
            ? new project_svelte_files_1.ProjectSvelteFilesManager(modules.typescript, info.project, info.serverHost, snapshotManager, parsedCommandLine, configManager)
            : undefined;
        (0, module_loader_1.patchModuleLoader)(logger, snapshotManager, modules.typescript, info.languageServiceHost, info.project, configManager);
        configManager.onConfigurationChanged(() => {
            // enabling/disabling the plugin means TS has to recompute stuff
            info.languageService.cleanupSemanticCache();
            info.project.markAsDirty();
            // updateGraph checks for new root files
            // if there's no tsconfig there isn't root files to check
            if (projectSvelteFilesManager) {
                info.project.updateGraph();
            }
        });
        return decorateLanguageServiceDispose((0, language_service_1.decorateLanguageService)(info.languageService, snapshotManager, logger, configManager), projectSvelteFilesManager !== null && projectSvelteFilesManager !== void 0 ? projectSvelteFilesManager : {
            dispose() { }
        });
    }
    function getExternalFiles(project) {
        var _a, _b;
        if (!isSvelteProject(project.getCompilerOptions()) || !configManager.getConfig().enable) {
            return [];
        }
        // Needed so the ambient definitions are known inside the tsx files
        const svelteTsPath = (0, path_1.dirname)(require.resolve('svelte2tsx'));
        const svelteTsxFiles = [
            './svelte-shims.d.ts',
            './svelte-jsx.d.ts',
            './svelte-native-jsx.d.ts'
        ].map((f) => modules.typescript.sys.resolvePath((0, path_1.resolve)(svelteTsPath, f)));
        // let ts know project svelte files to do its optimization
        return svelteTsxFiles.concat((_b = (_a = project_svelte_files_1.ProjectSvelteFilesManager.getInstance(project.getProjectName())) === null || _a === void 0 ? void 0 : _a.getFiles()) !== null && _b !== void 0 ? _b : []);
    }
    function isSvelteProject(compilerOptions) {
        // Add more checks like "no Svelte file found" or "no config file found"?
        try {
            const isSvelteProject = typeof compilerOptions.configFilePath !== 'string' ||
                require.resolve('svelte', { paths: [compilerOptions.configFilePath] });
            return isSvelteProject;
        }
        catch (e) {
            // If require.resolve fails, we end up here
            return false;
        }
    }
    function onConfigurationChanged(config) {
        configManager.updateConfigFromPluginConfig(config);
    }
    function decorateLanguageServiceDispose(languageService, disposable) {
        const dispose = languageService.dispose;
        languageService.dispose = () => {
            disposable.dispose();
            dispose();
        };
        return languageService;
    }
    return { create, getExternalFiles, onConfigurationChanged };
}
module.exports = init;
//# sourceMappingURL=index.js.map